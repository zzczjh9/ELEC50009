#include "system.h"
#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_timer.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <stdlib.h>
#include <math.h>  // for abs()


#define OFFSET      -32
#define PWM_PERIOD  16

/* Define the number of FIR taps.
 * For the simple 5-tap moving average, every coefficient is 0.2.
 * To extend to an N-tap filter, change the following definitions and
 * update the coefficients accordingly (e.g. by using MATLAB's designfilt). */
#define FIR_TAPS 5

alt_8 pwm = 0;
alt_u8 led;
int level;

/* FIR filter coefficients (simple 5-tap moving average) */
const float fir_coeff[FIR_TAPS] = {0.2f, 0.2f, 0.2f, 0.2f, 0.2f};

/* FIR filter function
 *
 * This function takes the current accelerometer reading as a float,
 * updates the internal buffer, and returns the filtered (averaged) value.
 *
 * To change to an N-tap filter, set FIR_TAPS accordingly and update the
 * fir_coeff array (possibly using coefficients generated by MATLAB).
 */
float fir_filter(float sample) {
    /* Static buffer to hold the most recent samples */
    static float buffer[FIR_TAPS] = {0.0f};
    float output = 0.0f;
    int i;

    /* Shift the existing samples in the buffer (oldest sample is dropped) */
    for (i = FIR_TAPS - 1; i > 0; i--) {
        buffer[i] = buffer[i - 1];
    }
    /* Store the newest sample at the beginning of the buffer */
    buffer[0] = sample;

    /* Compute the FIR filter output (convolution sum) */
    for (i = 0; i < FIR_TAPS; i++) {
        output += fir_coeff[i] * buffer[i];
    }
    return output;
}

/* LED write function */
void led_write(alt_u8 led_pattern) {
    IOWR(LED_BASE, 0, led_pattern);
}

/* Convert filtered accelerometer reading to LED pattern and level value.
 * (This is your original conversion routine.) */
void convert_read(alt_32 acc_read, int *level, alt_u8 *led) {
    acc_read += OFFSET;
    alt_u8 val = (acc_read >> 6) & 0x07;
    *led = (8 >> val) | (8 << (8 - val));
    *level = (acc_read >> 1) & 0x1f;
}

/* Timer ISR: uses the level value (from convert_read) to modulate the LED output */
void sys_timer_isr() {
    IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE, 0);

    if (pwm < abs(level)) {
        if (level < 0) {
            led_write(led << 1);
        } else {
            led_write(led >> 1);
        }
    } else {
        led_write(led);
    }

    if (pwm > PWM_PERIOD) {
        pwm = 0;
    } else {
        pwm++;
    }
}

/* Timer initialization (unchanged from your original code) */
void timer_init(void *isr) {
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, 0x0003);
    IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE, 0);
    IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_BASE, 0x0900);
    IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_BASE, 0x0000);
    alt_irq_register(TIMER_IRQ, 0, isr);
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, 0x0007);
}

int main(void) {
    alt_up_accelerometer_spi_dev *acc_dev;
    alt_32 x_read;
    float filtered_x;
    char buf[32];

    acc_dev = alt_up_accelerometer_spi_open_dev("/dev/accelerometer_spi");
    if (acc_dev == NULL) {
        alt_printf("Error: Could not open accelerometer device\n");
        return 1;
    }

    while(1) {
        alt_up_accelerometer_spi_read_x_axis(acc_dev, &x_read);
        filtered_x = fir_filter((float)x_read);

        // Scale by 1000 to preserve 3 decimal places and convert to integer:
        int scaled = (int)(filtered_x * 1000);
        // Format the string manually:
        sprintf(buf, "Filtered reading: %d.%03d\n", scaled / 1000, abs(scaled % 1000));
        alt_printf("%s", buf);
    }

    return 0;
}

